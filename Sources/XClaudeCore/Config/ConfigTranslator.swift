import Foundation

/// Translates xclaude.toml to Bundler.toml
public struct ConfigTranslator {
  /// Directory for derived files
  public static func derivedDirectory(for project: URL) -> URL {
    project.appendingPathComponent(".xclaude").appendingPathComponent("derived")
  }

  /// Path to generated Bundler.toml
  public static func bundlerConfigPath(for project: URL) -> URL {
    derivedDirectory(for: project).appendingPathComponent("Bundler.toml")
  }

  /// Translate xclaude.toml to Bundler.toml
  /// Returns path to generated Bundler.toml
  public static func translate(config: XClaudeConfig, projectDirectory: URL) throws -> URL {
    let derivedDir = derivedDirectory(for: projectDirectory)
    let bundlerPath = bundlerConfigPath(for: projectDirectory)

    // Create derived directory
    try FileManager.default.createDirectory(at: derivedDir, withIntermediateDirectories: true)

    // Generate Bundler.toml content
    let content = generateBundlerTOML(config: config, projectDirectory: projectDirectory)

    // Write file
    try content.write(to: bundlerPath, atomically: true, encoding: .utf8)

    // Also create symlink to icon if it exists (preserving original filename)
    let iconSource = projectDirectory.appendingPathComponent(config.app.icon)
    let iconFilename = (config.app.icon as NSString).lastPathComponent
    let iconDest = derivedDir.appendingPathComponent(iconFilename)

    if FileManager.default.fileExists(atPath: iconSource.path) {
      // Remove existing symlink/file
      try? FileManager.default.removeItem(at: iconDest)
      // Create symlink
      try FileManager.default.createSymbolicLink(at: iconDest, withDestinationURL: iconSource)
    }

    return bundlerPath
  }

  /// Generate Bundler.toml content
  private static func generateBundlerTOML(config: XClaudeConfig, projectDirectory: URL) -> String {
    var lines: [String] = []

    lines.append("# Generated by xclaude - DO NOT EDIT")
    lines.append("# Source: xclaude.toml")
    lines.append("# Generated: \(ISO8601DateFormatter().string(from: Date()))")
    lines.append("")
    lines.append("format_version = 2")
    lines.append("")
    lines.append("[apps.\(config.app.name)]")
    lines.append("identifier = \"\(config.app.bundleId)\"")
    lines.append("product = \"\(config.app.name)\"")
    lines.append("version = \"\(config.app.version)\"")

    // Check if icon exists - use the actual configured path
    let iconPath = projectDirectory.appendingPathComponent(config.app.icon)
    if FileManager.default.fileExists(atPath: iconPath.path) {
      lines.append("icon = \"\(config.app.icon)\"")
    }

    // Add Info.plist additions from capabilities (if present)
    let infoAdditionsPath = derivedDirectory(for: projectDirectory)
      .appendingPathComponent("InfoAdditions.plist")
    if FileManager.default.fileExists(atPath: infoAdditionsPath.path),
       let data = try? Data(contentsOf: infoAdditionsPath),
       let plist = try? PropertyListSerialization.propertyList(from: data, format: nil) as? [String: String],
       !plist.isEmpty {
      lines.append("")
      lines.append("[apps.\(config.app.name).plist]")
      for (key, value) in plist.sorted(by: { $0.key < $1.key }) {
        // Escape the value for TOML
        let escapedValue = value.replacingOccurrences(of: "\\", with: "\\\\")
          .replacingOccurrences(of: "\"", with: "\\\"")
        lines.append("\"\(key)\" = \"\(escapedValue)\"")
      }
    }

    return lines.joined(separator: "\n") + "\n"
  }

  /// Check if project has xclaude.toml
  public static func hasXClaudeConfig(at directory: URL) -> Bool {
    let configPath = directory.appendingPathComponent("xclaude.toml")
    return FileManager.default.fileExists(atPath: configPath.path)
  }

  /// Check if project has Bundler.toml (existing swift-bundler project)
  public static func hasBundlerConfig(at directory: URL) -> Bool {
    let configPath = directory.appendingPathComponent("Bundler.toml")
    return FileManager.default.fileExists(atPath: configPath.path)
  }

  /// Detect project type
  public static func detectProjectType(at directory: URL) -> ProjectType {
    if hasXClaudeConfig(at: directory) {
      return .xclaude
    } else if hasBundlerConfig(at: directory) {
      return .swiftBundler
    } else if FileManager.default.fileExists(atPath: directory.appendingPathComponent("Package.swift").path) {
      return .swiftPackage
    } else {
      return .unknown
    }
  }

  /// Create minimal xclaude.toml for existing Package.swift project
  public static func initializeXClaudeConfig(at directory: URL, appName: String? = nil) throws -> XClaudeConfig {
    // Try to detect app name from Package.swift
    let name: String
    if let provided = appName {
      name = provided
    } else {
      name = try detectAppName(at: directory) ?? "App"
    }

    let config = XClaudeConfig(
      app: AppConfig(
        name: name,
        bundleId: XClaudeConfig.deriveBundleId(from: name)
      )
    )

    try config.save(to: directory)
    return config
  }

  /// Try to detect app name from Package.swift
  private static func detectAppName(at directory: URL) throws -> String? {
    let packagePath = directory.appendingPathComponent("Package.swift")
    guard FileManager.default.fileExists(atPath: packagePath.path) else {
      return nil
    }

    let content = try String(contentsOf: packagePath, encoding: .utf8)

    // Look for: name: "AppName" in Package definition
    // Simple regex-like search
    if let nameRange = content.range(of: "name:\\s*\"([^\"]+)\"", options: .regularExpression) {
      let match = content[nameRange]
      if let quoteStart = match.firstIndex(of: "\""),
         let quoteEnd = match.lastIndex(of: "\""),
         quoteStart != quoteEnd {
        let nameRange = content.index(after: quoteStart)..<quoteEnd
        return String(match[nameRange])
      }
    }

    return nil
  }
}

/// Project type detection
public enum ProjectType {
  case xclaude       // Has xclaude.toml
  case swiftBundler  // Has Bundler.toml
  case swiftPackage  // Has Package.swift only
  case unknown
}
